<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Driver Map - Step-by-Step with Simulated Driver Position</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600&display=swap">


  <!-- Leaflet & Turf -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: 'Manrope', sans-serif;
      background-color: #ffffff;
      color: #0B437E;
    }
    :root {
      --bs-primary: #0B437E;
    }


    .navbar {
      background-color: #0B437E !important;
    }

    #map {
      width: 100%;
      height: calc(100vh - 100px - 56px);
    }

    #directionControl {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 100px;
      background-color: #0B437E;
      color: #fff;
      z-index: 9999;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      transition: all 0.3s ease;
      overflow: hidden;
    }

    #startBtn {
      background-color: #0B437E;
      color: #fff;
      border: 2px solid #fff;
      border-radius: 6px;
      font-size: 20px;
      padding: 10px 40px;
      cursor: pointer;
      transition: opacity 0.3s ease;
    }

    #stepContainer {
      width: 100%;
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      opacity: 0;
      transition: opacity 0.3s ease;
      padding: 10px;
    }

    #directionText {
      color: #fff;
      font-size: 16px;
      text-align: center;
      margin-bottom: 10px;
      min-height: 40px;
    }

    #nextBtn {
      background-color: #3d5060;
      color: #fff;
      border: none;
      border-radius: 6px;
      font-size: 16px;
      padding: 10px 20px;
      cursor: pointer;
    }

    .fadeOut {
      opacity: 0 !important;
    }
    .fadeIn {
      display: flex !important;
      opacity: 1 !important;
    }

    .btn-primary:hover, #startBtn:hover, #nextBtn:hover {
      background-color: #083c63;
      border-color: #083c63;
    }
  </style>
</head>
<body>
  <!-- Navbar -->
  <nav class="navbar navbar-expand-lg navbar-dark">
    <div class="container-fluid">
      <a class="navbar-brand fw-bold" href="#">CleanUP</a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav me-auto">
          <li class="nav-item">
            <a class="nav-link active" href="#">Home</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">About</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="#">Contact</a>
          </li>
        </ul>
        <span class="navbar-text fw-semibold">
          Driver Map
        </span>
      </div>
    </div>
  </nav>

  <div id="map"></div>

  <div id="directionControl">

    <button id="startBtn">Start</button>

    <div id="stepContainer">
      <div id="directionText"></div>
      <button id="nextBtn">Next</button>
    </div>
  </div>

  <script>

    //  Initialize the Map
    const map = L.map("map").setView([6.8330, 79.8690], 15);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: "© OpenStreetMap contributors",
    }).addTo(map);

    let driverMarker = null;


    // Overpass + Weighted Graph Setup
    const OVERPASS_API_URL =
        "https://overpass-api.de/api/interpreter?data=[out:json];way[highway](6.80,79.84,6.87,79.89);out geom;";

    const roadTypeWeights = {
      motorway: 1,
      primary: 1.2,
      secondary: 1.5,
      tertiary: 1.8,
      residential: 2,
      service: 2.5,
      path: 4,
    };

    const roadsWithGarbage = new Set([
      "6.832870,79.868815",
      "6.830379,79.867886",
      "6.828325,79.871037",
      "6.826814,79.871954"
    ]);

    async function fetchRoadData() {
      try {
        const response = await fetch(OVERPASS_API_URL);
        if (!response.ok) {
          throw new Error(`Error fetching road data: ${response.statusText}`);
        }
        return await response.json();
      } catch (error) {
        console.error("Road data fetch failed:", error);
        return null;
      }
    }

    //  Build Weighted Graph & Store Road Names
    function buildWeightedGraph(roadData) {
      const graph = {};

      roadData.elements.forEach((way) => {
        if (way.type === "way" && way.geometry) {
          const roadType = way.tags.highway || "unknown";
          const wayName = way.tags.name || "";
          const wayRef = way.tags.ref || "";
          const combinedName = (wayName && wayRef)
            ? `${wayName} (${wayRef})`
            : (wayName || wayRef || "Unnamed Road");

          let baseWeight = roadTypeWeights[roadType] || 2;
          const coords = way.geometry;

          for (let i = 0; i < coords.length - 1; i++) {
            const start = coords[i];
            const end = coords[i + 1];

            const distanceKm = turf.distance(
              [start.lon, start.lat],
              [end.lon, end.lat],
              { units: "kilometers" }
            );

            let weightFactor = baseWeight;
            const startNode = `${start.lat},${start.lon}`;
            const endNode = `${end.lat},${end.lon}`;

            // If there's waste, reduce the weight factor
            if (roadsWithGarbage.has(startNode) || roadsWithGarbage.has(endNode)) {
              weightFactor *= 0.5;
            }

            const weightedDistance = distanceKm * weightFactor;

            if (!graph[startNode]) graph[startNode] = {};
            if (!graph[endNode]) graph[endNode] = {};

            graph[startNode][endNode] = {
              distance: weightedDistance,
              roadName: combinedName
            };
            graph[endNode][startNode] = {
              distance: weightedDistance,
              roadName: combinedName
            };
          }
        }
      });

      return graph;
    }

    //Find Closest Node & Bidirectional Dijkstra
    function findClosestNode(graph, lat, lon) {
      let closestNode = null;
      let smallestDistance = Infinity;

      for (const node in graph) {
        const [nodeLat, nodeLon] = node.split(",").map(Number);
        const dist = turf.distance([lon, lat], [nodeLon, nodeLat], { units: "kilometers" });
        if (dist < smallestDistance) {
          smallestDistance = dist;
          closestNode = node;
        }
      }
      return closestNode;
    }

    function bidirectionalDijkstra(graph, start, end) {
      if (!graph[start] || !graph[end]) {
        console.error(`Start or End node missing: ${start}, ${end}`);
        return [];
      }

      const forwardDistances = { [start]: 0 };
      const backwardDistances = { [end]: 0 };
      const forwardPrev = {};
      const backwardPrev = {};
      const forwardQueue = [start];
      const backwardQueue = [end];
      const visitedForward = new Set();
      const visitedBackward = new Set();

      let mu = Infinity;
      let meetingNode = null;

      while (forwardQueue.length && backwardQueue.length) {
        // Forward
        let u = forwardQueue.reduce((a, b) => forwardDistances[a] < forwardDistances[b] ? a : b);
        forwardQueue.splice(forwardQueue.indexOf(u), 1);
        visitedForward.add(u);

        for (const neighbor in graph[u]) {
          if (!visitedForward.has(neighbor)) {
            const newDist = forwardDistances[u] + graph[u][neighbor].distance;
            if (newDist < (forwardDistances[neighbor] || Infinity)) {
              forwardDistances[neighbor] = newDist;
              forwardPrev[neighbor] = u;
              forwardQueue.push(neighbor);
            }
            if (visitedBackward.has(neighbor)) {
              const total = forwardDistances[neighbor] + backwardDistances[neighbor];
              if (total < mu) {
                mu = total;
                meetingNode = neighbor;
              }
            }
          }
        }

        // Backward
        let v = backwardQueue.reduce((a, b) => backwardDistances[a] < backwardDistances[b] ? a : b);
        backwardQueue.splice(backwardQueue.indexOf(v), 1);
        visitedBackward.add(v);

        for (const neighbor in graph[v]) {
          if (!visitedBackward.has(neighbor)) {
            const newDist = backwardDistances[v] + graph[v][neighbor].distance;
            if (newDist < (backwardDistances[neighbor] || Infinity)) {
              backwardDistances[neighbor] = newDist;
              backwardPrev[neighbor] = v;
              backwardQueue.push(neighbor);
            }
            if (visitedForward.has(neighbor)) {
              const total = forwardDistances[neighbor] + backwardDistances[neighbor];
              if (total < mu) {
                mu = total;
                meetingNode = neighbor;
              }
            }
          }
        }

        if (forwardDistances[u] + backwardDistances[v] >= mu) {
          break;
        }
      }

      // Reconstruct path
      const pathForward = [];
      let current = meetingNode;
      while (current) {
        pathForward.unshift(current);
        current = forwardPrev[current];
      }
      const pathBackward = [];
      current = backwardPrev[meetingNode];
      while (current) {
        pathBackward.push(current);
        current = backwardPrev[current];
      }
      return pathForward.concat(pathBackward);
    }


    // Build Directions with Positions
    function buildDirectionsWithPositions(path, graph) {
      const steps = [];
      let currentStep = null;
      let prevBearing = null;
      function finalizeStep(endIndex, instruction) {
        if (endIndex >= path.length) return;
        const endCoordStr = path[endIndex];
        const [endLat, endLon] = endCoordStr.split(",").map(Number);
        steps.push({
          instruction,
          lat: endLat,
          lon: endLon
        });
      }
      for (let i = 0; i < path.length - 1; i++) {
        const currNode = path[i];
        const nextNode = path[i + 1];
        const edgeData = graph[currNode]?.[nextNode];
        if (!edgeData) continue;
        const distanceM = edgeData.distance * 1000;
        const roadName = edgeData.roadName;
        const [lat1, lon1] = currNode.split(",").map(Number);
        const [lat2, lon2] = nextNode.split(",").map(Number);
        const b = turf.bearing(turf.point([lon1, lat1]), turf.point([lon2, lat2]));
        const bearing = (b + 360) % 360;
        const cardinalDir = (bearing >= 22.5 && bearing < 67.5) ? "northeast" :
                             (bearing >= 67.5 && bearing < 112.5) ? "east" :
                             (bearing >= 112.5 && bearing < 157.5) ? "southeast" :
                             (bearing >= 157.5 && bearing < 202.5) ? "south" :
                             (bearing >= 202.5 && bearing < 247.5) ? "southwest" :
                             (bearing >= 247.5 && bearing < 292.5) ? "west" :
                             (bearing >= 292.5 && bearing < 337.5) ? "northwest" : "north";
        let turnDir = "straight";
        if (prevBearing !== null) {
          const turnAngle = (bearing - prevBearing + 360) % 360;
          if (turnAngle > 30 && turnAngle < 180) {
            turnDir = "right";
          } else if (turnAngle >= 180 && turnAngle < 330) {
            turnDir = "left";
          }
        }
        if (!currentStep) {
          currentStep = {
            roadName,
            totalDistance: distanceM,
            directionText: cardinalDir,
            arrow: "↑",
            turnDir: "straight",
            isFirstStep: true
          };
        } else {
          if (roadName === currentStep.roadName && turnDir === "straight" && currentStep.turnDir === "straight") {
            currentStep.totalDistance += distanceM;
          } else {
            const arrow = currentStep.arrow || "↑";
            let instruction;
            if (currentStep.isFirstStep) {
              instruction = `${arrow} Head ${currentStep.directionText} on ${currentStep.roadName} for ${currentStep.totalDistance.toFixed(0)} m`;
            } else {
              instruction = currentStep.turnDir === "straight" ?
                `${arrow} Continue on ${currentStep.roadName} for ${currentStep.totalDistance.toFixed(0)} m` :
                `${arrow} Turn ${currentStep.turnDir} onto ${currentStep.roadName} for ${currentStep.totalDistance.toFixed(0)} m`;
            }
            finalizeStep(i, instruction);
            currentStep = {
              roadName,
              totalDistance: distanceM,
              directionText: cardinalDir,
              arrow: (turnDir === "left") ? "←" : (turnDir === "right") ? "→" : "↑",
              turnDir,
              isFirstStep: false
            };
          }
        }
        prevBearing = bearing;
      }
      if (currentStep) {
        const arrow = currentStep.arrow || "↑";
        let instruction = currentStep.isFirstStep ?
          `${arrow} Head ${currentStep.directionText} on ${currentStep.roadName} for ${currentStep.totalDistance.toFixed(0)} m` :
          (currentStep.turnDir === "straight" ?
          `${arrow} Continue on ${currentStep.roadName} for ${currentStep.totalDistance.toFixed(0)} m` :
          `${arrow} Turn ${currentStep.turnDir} onto ${currentStep.roadName} for ${currentStep.totalDistance.toFixed(0)} m`);
        finalizeStep(path.length - 1, instruction);
      }
      return steps;
    }


    //load the assigned route from driver_routes and visualize
    async function loadAssignedStops() {
      try {
        const response = await fetch('/routeOptimization/api/driver-route');
        if (!response.ok) {
          console.error("No route assigned or not logged in.");
          return;
        }
        const data = await response.json();
        if (data.error) {
          console.error(data.error);
          return;
        }
        const routePoints = data.route;
        console.log("Assigned route:", routePoints);

        const latLngs = routePoints.map(pt => {
          const [latStr, lonStr] = pt.split(",");
          return [parseFloat(latStr), parseFloat(lonStr)];
        });

        latLngs.forEach((coord, idx) => {
          L.circleMarker(coord, {
            radius: 5,
            color: "#000000",
            fillColor: "#000000",
            fillOpacity: 0.8
          })
          .addTo(map)
          .bindPopup(`Stop #${idx + 1}`);
        });

        if (latLngs.length > 1) {
          L.polyline(latLngs, { color: "red", weight: 4 }).addTo(map);
        }

        if (latLngs.length > 0) {
          map.fitBounds(latLngs);
        }

        const roadData = await fetchRoadData();
        if (!roadData || !roadData.elements) return;
        const graph = buildWeightedGraph(roadData);

        const allSteps = buildDirectionsWithPositions(routePoints, graph);

        if (latLngs.length > 0) {
          driverMarker = L.marker(latLngs[0], {
            icon: L.icon({
              iconUrl: "https://cdn-icons-png.flaticon.com/512/684/684908.png",
              iconSize: [35, 35],
              iconAnchor: [17, 35]
            })
          }).addTo(map);
          map.setView(latLngs[0], 17);
        }

        const startBtn = document.getElementById("startBtn");
        const stepContainer = document.getElementById("stepContainer");
        const directionText = document.getElementById("directionText");
        const nextBtn = document.getElementById("nextBtn");
        let currentIndex = -1;

        function showNextStep() {
          currentIndex++;
          if (currentIndex < allSteps.length) {
            const step = allSteps[currentIndex];
            directionText.textContent = step.instruction;
            if (step.lat !== null && step.lon !== null && driverMarker) {
              driverMarker.setLatLng([step.lat, step.lon]);
              map.panTo([step.lat, step.lon]);
            }
            nextBtn.disabled = false;
          } else {
            directionText.textContent = "Route Completed!";
            nextBtn.disabled = true;
          }
        }

        startBtn.addEventListener("click", () => {
          startBtn.classList.add("fadeOut");
          setTimeout(() => {
            startBtn.style.display = "none";
            stepContainer.style.display = "flex";
            stepContainer.classList.add("fadeIn");
            showNextStep();
          }, 300);
        });

        nextBtn.addEventListener("click", showNextStep);

      } catch (err) {
        console.error("Failed to load assigned route:", err);
      }
    }

    window.onload = loadAssignedStops;
  </script>
</body>
</html>
